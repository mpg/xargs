                            Trucs à faire pour xargs
                            ------------------------

% Pour la prochaine version
% -------------------------

[ ] Penser à décommenter le test dans la doc. De façon générale, bien relire la
    doc et surtout celle du code en ajoutant les \begin{macro} kivonbien. (Tenir
    compte des trucs gribouillés sur papier v1.0 pour commencer.) (Créer, sous
    une forme ou une autre, des sous-section et les munir de liens cliquables
    (cf minitoc).)

[ ] Suite de test :
    [ ] test de chaque commande, cas de base ; (reste \CCx à faire)
    [ ] gestion des arguments : indep de la forme (courte) et de l'ordre ;
    [ ] préfixe pour chaque commande + \Check-compatibilité avec LaTeX ;
    [ ] présence de \ifs (def, val par défaut, val d'arguments (opt ou pas)) ;
    [ ] espaces parasites pour chaque commande dans un max de situations ;
    [ ] présence de \par partout (avec ou sans ted) ;
    [ ] robustesse des commandes définies ;
    [ ] messages d'erreur ;
    [ ] c'est tout pour cette fois...

[ ] Relire les usages de \@onlypreamble (fautes de frappe).

[x] Revoir les conditions d'explosion de \newcommand avec des # ou des \if.
    -> Résultat : tout marche bien avec les \if, les # dans un argument optionel
    sont OK, mais pas dans une valeur par défaut. 

[x] Mettre tout le code de parsing dans un groupe, par propreté.

[ ] [fait, mais] Ajouter une option pour le préfixe (\long, etc)
    [x] Regarder individuellement chaque variante : choix du comportement
    adéquat, test de ce comportement. (En part, env et \DRCx.) (Tenir compte de
    la compatibilité LaTeX.)
    [ ] Regarder pour \CheckCommandx.

[x] (Abandon) Rendre tout robuste à la présence de \if et de # !
    État actuel : ok (sous réserves) pour les \if dans le texte de def ou dans
    les valeurs d'arguments, mais PB si \if dans une <liste>.
    -> Résultat : le problème avec les \if vient de xkeyval. À moins d'un
    pré-traitement intensif par ted, il n'y a rien à faire. On abandonne sur ce
    front.
    Pour les #, même combat : ils marchent partout mais pas dans une <liste>.
    Même motif, même punition.

[x] Documenter les limitations connues dans une sous-section à part (#, \if,
    \par).

[x] Voir le truc à la \newlyxcommand... (Envoyé, en attente de retour des
    tests.)

% Plus tard, ou à repenser
% ------------------------

[ ] Mettre des \@ifdefinable autour des \define@key ? (Revoir les \@ifdefinable
    des macros internes genre \xargs@prefix, \xargs@default@flag, etc. Remarquer
    aussi que pas mal des trucs arrivent dans un groupe...) Point à joindre avec
    la vérification des usages de \xargs@temp. (Priorité basse.)

[ ] Vérifier les usages de \xargs@temp (portée, tout ça) (pas grave au fond)...
    ->  Relire le code.

[ ] Ajouter une option pour choisir le comportement du dernier test quant aux
    espaces. Difficile en fait : nécessite de calculer l'emplacement du dernier
    argument obligatoire. Cela en vaut-il vraiment la peine ?
        En fait, c'est sans doute plus facile de déterminer le dernier
        emplacement si on construit le parseur en partant de la fin. 
        Même comme ça, c'est pas clair que ça en vaut la peine, et il faut
        peut-être mieux que le traitement soit identique sur tous les espaces.
            Rajouter une option pour ça dans newcx, plus une globale pour
            choisir le comportement par défaut.

[ ] Réfléchir aux étoiles...
    Une bonne idée peut-être : voir dans newcx un clé star=combien, puis des
    clés precode0 à precodeN, et enfin prendre les définitions en plus comme des
    arg optionnels. Pb si le mec veut la même défintition dans le cas 0 et 1
    mais pas 2. À voir quand même.

